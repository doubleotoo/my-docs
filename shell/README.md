Shell
=====

Terminal colors:
* https://github.com/janlelis/paint


## find

Search for files in `<location>` created within a given `<time_period>`.

``bash
$ find <location> -ctime <time_period>
``

**Examples**:
* Created today: `-ctime 0`
* Created more than 30 days ago: `-ctime +30`
* Created less than 30 days ago: `-ctime -30`
* Created exactly than 30 days ago: `-ctime 30`


## printf

See http://wiki.bash-hackers.org/commands/builtin/printf.

Assign `printf` output to the variable `VAR` instead of printing to `stdout`:

* General Form:

  ```bash
  $ printf -v <VAR> "<STRING>"
  ```

* [Example](https://github.com/lehmannro/assert.sh/blob/master/assert.sh):

  ```bash
  $ printf -v _indent "\n\t"
  ```


## Interactive

If debugging, print progress indicator.

* For example, use a single dot `.` to produce a stream like `.......` for each
  step:

  ```bash
  $ [[ -n "$DEBUG" ]] && echo -n .
  ```


## Bash

### [The Double-Parentheses Construct](http://tldp.org/LDP/abs/html/dblparens.html)

```
Similar to the let command, the (( ... )) construct permits arithmetic expansion and evaluation.
In its simplest form, a=$(( 5 + 3 )) would set a to 5 + 3, or 8. However, this double-parentheses
construct is also a mechanism for allowing C-style manipulation of variables in Bash,
for example, (( var++ )).
```

### Rename function

See http://stackoverflow.com/a/1203628/870000.

```bash
# copies function named $1 to name $2
copy_function() {
    declare -F $1 > /dev/null || return 1
    eval "$(echo "${2}()"; declare -f ${1} | tail -n +2)"
}
```

Can be used like so:

```bash
$ theirfunc() { echo "do their thing"; }
$ copy_function theirfunc orig_theirfunc
$ theirfunc() { echo "do my thing"; orig_theirfunc; }
$ theirfunc
do my thing
do their thing
```

### List functions

* List names only

  ```bash
  $ declare -F
  declare -F
  declare -f __perlbrew_reinit
  declare -f __perlbrew_set_path
  declare -f _man_generic
  declare -f _opts
  declare -f dotcd
  declare -f dots
  declare -f filter
  declare -f gen_autocompletions
  declare -f help-gitsync
  declare -f hudson-rose
  declare -f perlbrew
  declare -f source_autocompletions
  declare -f term
  ```

  Note: You can use this to check if a function exists:

  ```bash
  $ declare -F $1 >/dev/null || <fail>
  ```

* List definitions

  ```bash
  $ declare -f
$$
  $ declare -f
  __perlbrew_reinit ()$
  {$
      if [[ ! -d $HOME/.perlbrew ]]; then
          mkdir -p $HOME/.perlbrew;
      fi;
      echo '# DO NOT EDIT THIS FILE' >|$HOME/.perlbrew/init;
      command perlbrew env $1 >> $HOME/.perlbrew/init;
      source $HOME/.perlbrew/init;
      __perlbrew_set_path
  }
  __perlbrew_set_path ()$
  {$
      [[ -z "$PERLBREW_ROOT" ]] && return 1;
      hash -d perl 2> /dev/null;
      export PATH_WITHOUT_PERLBREW=$(perl -e 'print join ":", grep { index($_, $ENV{PERLBREW_ROOT}) } split/:/,$ENV{PATH};');
      export PATH=$PERLBREW_PATH:$PATH_WITHOUT_PERLBREW
  }
  ```

### I/O Redirection

See http://stackoverflow.com/questions/3962674/how-do-these-stream-redirections-work.

```
3>&1: Open FD 3 to point to where stdout currently points.
1>&2: Reopen stdout to point to where stderr currently points.
2>&3: Reopen stderr to point to where FD 3 currently points, which is where stdout pointed before the previous step was completed. Now stdout and stderr have been succesfully swapped.
3>&-: Close FD 3 because it's not needed anymore.
```

### Traps

See http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_12_02.html.

