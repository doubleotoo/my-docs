Shell
=====

Terminal colors:
* https://github.com/janlelis/paint


## find

Search for files in `<location>` created within a given `<time_period>`.

``bash
$ find <location> -ctime <time_period>
``

**Examples**:
* Created today: `-ctime 0`
* Created more than 30 days ago: `-ctime +30`
* Created less than 30 days ago: `-ctime -30`
* Created exactly than 30 days ago: `-ctime 30`


## printf

See http://wiki.bash-hackers.org/commands/builtin/printf.

Assign `printf` output to the variable `VAR` instead of printing to `stdout`:

* General Form:

  ```bash
  $ printf -v <VAR> "<STRING>"
  ```

* [Example](https://github.com/lehmannro/assert.sh/blob/master/assert.sh):

  ```bash
  $ printf -v _indent "\n\t"
  ```


## Interactive

If debugging, print progress indicator.

* For example, use a single dot `.` to produce a stream like `.......` for each
  step:

  ```bash
  $ [[ -n "$DEBUG" ]] && echo -n .
  ```


## Bash

### [The Double-Parentheses Construct](http://tldp.org/LDP/abs/html/dblparens.html)

```
Similar to the let command, the (( ... )) construct permits arithmetic expansion and evaluation.
In its simplest form, a=$(( 5 + 3 )) would set a to 5 + 3, or 8. However, this double-parentheses
construct is also a mechanism for allowing C-style manipulation of variables in Bash,
for example, (( var++ )).
```

### Rename function

See http://stackoverflow.com/a/1203628/870000.

```bash
# copies function named $1 to name $2
copy_function() {
    declare -F $1 > /dev/null || return 1
    eval "$(echo "${2}()"; declare -f ${1} | tail -n +2)"
}
```

Can be used like so:

```bash
$ theirfunc() { echo "do their thing"; }
$ copy_function theirfunc orig_theirfunc
$ theirfunc() { echo "do my thing"; orig_theirfunc; }
$ theirfunc
do my thing
do their thing
```

### List functions

* List names only

  ```bash
  $ declare -F
  declare -F
  declare -f __perlbrew_reinit
  declare -f __perlbrew_set_path
  declare -f _man_generic
  declare -f _opts
  declare -f dotcd
  declare -f dots
  declare -f filter
  declare -f gen_autocompletions
  declare -f help-gitsync
  declare -f hudson-rose
  declare -f perlbrew
  declare -f source_autocompletions
  declare -f term
  ```

  Note: You can use this to check if a function exists:

  ```bash
  $ declare -F $1 >/dev/null || <fail>
  ```

* List definitions

  ```bash
  $ declare -f
$$
  $ declare -f
  __perlbrew_reinit ()$
  {$
      if [[ ! -d $HOME/.perlbrew ]]; then
          mkdir -p $HOME/.perlbrew;
      fi;
      echo '# DO NOT EDIT THIS FILE' >|$HOME/.perlbrew/init;
      command perlbrew env $1 >> $HOME/.perlbrew/init;
      source $HOME/.perlbrew/init;
      __perlbrew_set_path
  }
  __perlbrew_set_path ()$
  {$
      [[ -z "$PERLBREW_ROOT" ]] && return 1;
      hash -d perl 2> /dev/null;
      export PATH_WITHOUT_PERLBREW=$(perl -e 'print join ":", grep { index($_, $ENV{PERLBREW_ROOT}) } split/:/,$ENV{PATH};');
      export PATH=$PERLBREW_PATH:$PATH_WITHOUT_PERLBREW
  }
  ```

### I/O Redirection

See http://stackoverflow.com/questions/3962674/how-do-these-stream-redirections-work.

```
3>&1: Open FD 3 to point to where stdout currently points.
1>&2: Reopen stdout to point to where stderr currently points.
2>&3: Reopen stderr to point to where FD 3 currently points, which is where stdout pointed before the previous step was completed. Now stdout and stderr have been succesfully swapped.
3>&-: Close FD 3 because it's not needed anymore.
```

### Traps

See http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_12_02.html.


## Recipes

### Timeout

```bash
#!/bin/sh

# Execute a command with a timeout

# Author:
#    http://www.pixelbeat.org/
# Notes:
#    Note there is a timeout command packaged with coreutils since v7.0
#    If the timeout occurs the exit status is 124.
#    There is an asynchronous (and buggy) equivalent of this
#    script packaged with bash (under /usr/share/doc/ in my distro),
#    which I only noticed after writing this.
#    I noticed later again that there is a C equivalent of this packaged
#    with satan by Wietse Venema, and copied to forensics by Dan Farmer.
# Changes:
#    V1.0, Nov  3 2006, Initial release
#    V1.1, Nov 20 2007, Brad Greenlee <brad@footle.org>
#                       Make more portable by using the 'CHLD'
#                       signal spec rather than 17.
#    V1.3, Oct 29 2009, Ján Sáreník <jasan@x31.com>
#                       Even though this runs under dash,ksh etc.
#                       it doesn't actually timeout. So enforce bash for now.
#                       Also change exit on timeout from 128 to 124
#                       to match coreutils.
#    V2.0, Oct 30 2009, Ján Sáreník <jasan@x31.com>
#                       Rewritten to cover compatibility with other
#                       Bourne shell implementations (pdksh, dash)

if [ "$#" -lt "2" ]; then
    echo "Usage:   `basename $0` timeout_in_seconds command" >&2
    echo "Example: `basename $0` 2 sleep 3 || echo timeout" >&2
    exit 1
fi

cleanup()
{
    trap - ALRM               #reset handler to default
    kill -ALRM $a 2>/dev/null #stop timer subshell if running
    kill $! 2>/dev/null &&    #kill last job
      exit 124                #exit with 124 if it was running
}

watchit()
{
    trap "cleanup" ALRM
    sleep $1& wait
    kill -ALRM $$
}

watchit $1& a=$!         #start the timeout
shift                    #first param was timeout for sleep
trap "cleanup" ALRM INT  #cleanup after timeout
"$@"& wait $!; RET=$?    #start the job wait for it and save its return value
kill -ALRM $a            #send ALRM signal to watchit
wait $a                  #wait for watchit to finish cleanup
exit $RET                #return the value
```